<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="copyright" content="Carlos Amengual">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="usage-e.css" rel="stylesheet" type="text/css" />
<title>CSS4J Quick Start User Guide</title>
<script src="js/usage-d.js" type="text/javascript" charset="utf-8"></script>
</head>
<body>
<div class="layout">
<div id="hdr01"></div>
<a id="mylinkhome" href="/"><span>CSS4J</span></a>
</div>
<div class="container">
<div class="menu">
<ul class="menulist">
<li><a id="mnuindice" href="/"><span>Home</span></a></li>
<li><div id="mnuusage-sel"><span>Usage</span></div></li>
<li class="menulvl2"><a id="mnuembedsvg" href="embed-svg.html"><span>Embed SVG</span></a></li>
<li class="menulvl2"><a id="mnuresolver" href="resolver.html"><span>Resolver</span></a></li>
<li><a id="mnuapi2" href="api/latest/"><span>Latest API</span></a></li>
<li><a id="mnufaq" href="faq.html"><span>FAQ</span></a></li>
<li><a id="mnubenchmarks" href="benchmarks.html"><span>Benchmarks</span></a></li>
<li><a id="mnugithub" href="https://github.com/css4j"><span>Github</span></a></li>
</ul>
</div>
<div class="beforemain"></div>
<div class="main">
<div id="presentacion_top" class="textheader"><span>Usage</span></div>
<div class="cos">
<h1>CSS4J User Guide</h1>
<p>This project is an implementation of W3C's <a href="https://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/" target="_blank">CSS Object Model API</a>
in the Java&trade; language, and also adds CSS support to the <a href="https://dom4j.github.io/" target="_blank">DOM4J</a> package. It
targets several different use cases, with functionalities from style sheet error detection to style computation.</p>
<p>Java 8 and later versions are supported (the library is fully modular).</p>
<div class="tema" id="overview">
<h2>Overview</h2>
<p>This library provides a number of classes to deal with different CSS Object Model abstractions. For example:</p>
<ul>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/AbstractCSSStyleSheet.html">AbstractCSSStyleSheet</a>
for style sheets.</li>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/StyleRule.html">StyleRule</a>
for style rules.</a></li>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/property/StyleValue.html">StyleValue</a>
for values like <code>rgb(12% 0% 67%)</code> or <code>var(--customProperty)</code>.</li>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/nsac/LexicalUnit.html">LexicalUnit</a>
for low-level CSS syntax.</li>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/nsac/Selector.html">Selector</a>
and <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/nsac/SelectorList.html">SelectorList</a>
for <a href="https://www.w3.org/TR/selectors-4/" target="_blank">CSS Selectors</a>.</li>
</ul>
<p>You can use those classes as stand-alone objects or have them all together in a document, one of the implementations
of the <a href="https://dom.spec.whatwg.org/" target="_blank">DOM</a>-based <a class="codeitem"
href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSDocument.html">CSSDocument</a> interface:</p>
<ul>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/dom/HTMLDocument.html">HTMLDocument</a> and
<a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/dom/DOMDocument.html">DOMDocument</a>
of css4j's native DOM, available from the <a href="api/latest/io.sf.carte.css4j/module-summary.html">core css4j module</a>.
Native DOM is recommended for new projects.</li>
<li>The <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/StylableDocumentWrapper.html">StylableDocumentWrapper</a>
can wrap any valid DOM document, thus adding (read-only) style capabilities to a pre-existing document in your favourite
DOM implementation. The documentation often refers to this approach as the "DOM Wrapper", and is also available from the
<a href="api/latest/io.sf.carte.css4j/module-summary.html">core css4j module</a>.</li>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j.dom4j/io/sf/carte/doc/dom4j/XHTMLDocument.html">XHTMLDocument</a>
is a DOM4J subclass which comes with the <a href="api/latest/io.sf.carte.css4j.dom4j/module-summary.html">css4j-dom4j
module</a>. Recommended only for dealing with legacy DOM4J code.</li>
</ul>
<p>An important advantage of using <a href="http://www.w3.org/DOM/" target="_blank">DOM</a>-based interfaces is that you
can use the same or very similar methods in your web browser's Javascript (with the exception of the <a class="codeitem"
href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSValue.html">CSSValue</a> API which
is based on an old W3C standard instead of the more recent Houdini's Typed OM).</p>
<h3 class="subtema" id="choosing-dom">Choosing a DOM implementation</h3>
<p>Once you have chosen which DOM you prefer to use, the first step is to obtain an instance of a compatible
<a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheetFactory.html">CSSStyleSheetFactory</a>.
<p>There are three implementations of that interface:</p>
<ul>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/dom/CSSDOMImplementation.html">CSSDOMImplementation</a>, the native DOM implementation.</li>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/DOMCSSStyleSheetFactory.html">DOMCSSStyleSheetFactory</a> for the DOM Wrapper.</li>
<li>If you use DOM4J, get it through <a class="codeitem"
href="api/latest/io.sf.carte.css4j.dom4j/io/sf/carte/doc/dom4j/XHTMLDocumentFactory.html#getStyleSheetFactory()">XHTMLDocumentFactory.getInstance().getStyleSheetFactory()</a>.</li>
</ul>
<p>Even if you want to use only stand-alone style sheets, you should use one of the above factories to create them with the
<a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/AbstractCSSStyleSheetFactory.html#createStyleSheet(java.lang.String,io.sf.carte.doc.style.css.MediaQueryList)">createStyleSheet("<i>title</i>",
"<i>media</i>")</a> method.</p>
<p>The style sheet objects created by that method are empty, but you can load the style sheet rules with the
<a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/AbstractCSSStyleSheet.html#parseStyleSheet(java.io.Reader,short)">AbstractCSSStyleSheet.parseStyleSheet(<i>reader</i>,
<i>short</i>)</a> method (see <a href="#sheetparsing">Parsing a Style Sheet</a>).</p>
</div>
<div class="tema" id="modules">
<h2>Modules</h2>
<p>The project is organized in several modules:</p>
<ul>
<li><a href="https://github.com/css4j/css4j"><code>css4j</code></a> core module (providing the <a href="api/latest/io.sf.carte.css4j/module-summary.html">io.sf.carte.css4j</a>
JPMS module), which depends on the next two (they are included in the Zip distribution):</li>
<li><a href="api/carte-util/3/"><code>carte-util</code></a>, a very small collection of interfaces and utility classes.</li>
<li><a href="https://github.com/css4j/tokenproducer"><code>tokenproducer</code></a>, the low-level parser at the core of css4j.</li>
<li><a href="https://github.com/css4j/css4j-agent"><code>css4j-agent</code></a>, an optional collection of agent-related
classes that makes the processing of remote documents a bit easier. JPMS module: <a
href="api/latest/io.sf.carte.css4j.agent.net/module-summary.html">io.sf.carte.css4j.agent.net</a>.</li>
<li><a href="https://github.com/css4j/css4j-awt"><code>css4j-awt</code></a>, a small set of <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/package-summary.html">AWT</a>-related
utility classes (also optional). Module: <a href="api/latest/io.sf.carte.css4j.awt/module-summary.html">io.sf.carte.css4j.awt</a>.</li>
<li><a href="https://github.com/css4j/css4j-dom4j"><code>css4j-dom4j</code></a>: to use css4j together with dom4j, if you prefer that API.
The JPMS module name is <a href="api/latest/io.sf.carte.css4j.dom4j/module-summary.html">io.sf.carte.css4j.dom4j</a>.</li>
<li><a href="https://github.com/css4j/xml-dtd"><code>xml-dtd</code></a> is a small set of classes to aid in the processing of XML <a href="https://en.wikipedia.org/wiki/Document_type_definition"
target="_blank">DTD</a>s, including the useful <a class="codeitem" href="api/latest/io.sf.carte.xml.dtd/io/sf/carte/doc/xml/dtd/DefaultEntityResolver.html">DefaultEntityResolver</a>.
It is not needed if you do not process XML. The JPMS module is <a
href="api/latest/io.sf.carte.xml.dtd/module-summary.html">io.sf.carte.xml.dtd</a>.</li>
</ul>
<p>In general, you'll need to have at least <code>css4j</code>, <code>carte-util</code> and <code>tokenproducer</code> in your classpath/modulepath.
If you use <a href="https://gradle.org/" target="_blank">Gradle</a> or <a href="https://maven.apache.org/" target="_blank">Apache Maven</a>, you may want to look at each module's
<code>build.gradle</code> files (or even better, the <a href="https://css4j.github.io/maven/io/sf/carte/css4j-dom4j/4.0/css4j-dom4j-4.0.pom"><code>.pom</code></a>
or the <a href="https://css4j.github.io/maven/io/sf/carte/css4j-dom4j/4.0/css4j-dom4j-4.0.module"><code>.module</code> files at the repository</a>) to check for the specific module dependencies.</p>
<p>Recent <code>css4j-*</code> artifacts are compatible with <code>css4j</code> releases that have the same major version number, for example <code>css4j-dom4j</code> 3.6.1 is compatible with
<code>css4j</code> 3.6.1 and also with 3.9.1. (css4j-dom4j 4.x is recommended for css4j 4.x compatibility)</p>
<h3 class="subtema" id="gradle">Usage from a Gradle project</h3>
<p>
If your Gradle project depends on css4j, you can use this project's own Maven repository in a <code>repositories</code> section of
your build file:
</p>
<pre class="code"><code class="language-groovy">repositories {
    maven {
        url "https://css4j.github.io/maven/"
        mavenContent {
            releasesOnly()
        }
        content {
            includeGroup 'io.sf.carte'
            includeGroup 'io.sf.jclf'
            includeGroup 'xmlpull'
            includeGroup 'xpp3'
        }
    }
}
</code></pre>
<p>
please use this repository <b>only</b> for the artifact groups listed in the <code>includeGroup</code> statements.
</p>
<p>
Then, in your <code>build.gradle</code> file:
</p>
<pre class="code"><code class="language-groovy">dependencies {
    api "io.sf.carte:css4j:${css4jVersion}"
}
</code></pre>
<p>
where <code>css4jVersion</code> could be defined in a <code>gradle.properties</code> file.
</p>
<h3 class="subtema" id="maven">Usage from a Maven build</h3>
<p>
If you build your project (that depends on css4j) with Apache Maven, please note that some of the css4j dependencies are not in
Maven Central:
</p>
<ul>
<li><a href="https://sourceforge.net/projects/jclf/">JCLF</a>.</li>
<li><a href="https://github.com/xmlpull-xpp3/xmlpull-xpp3">XMLPull-XPP3</a> (v1.2, dependency of the DOM4J module only).</li>
</ul>
<p>
You may want to install them manually into your local Maven repository, which can be done easily with the:
</p>
<ul>
<li><a href="https://raw.githubusercontent.com/css4j/css4j-dist/master/maven/install-jclf.sh"><code>install-jclf.sh</code></a></li>
<li><a href="https://raw.githubusercontent.com/css4j/css4j-dist/master/maven/install-xpp3.sh"><code>install-xpp3.sh</code></a></li>
</ul>
<p>
scripts.
</p>
<p>
You can also directly install the CSS4J artifacts into your local Maven repository, with the similar
<a href="https://raw.githubusercontent.com/css4j/css4j-dist/master/maven/install-css4j.sh"><code>install-css4j.sh</code></a>.
</p>
<p>
And then, add the following to the <code>&lt;dependencies&gt;</code> section of your <code>pom.xml</code>:
</p>
<pre class="code"><code class="language-xml">&lt;!-- This artifact is not in Maven Central --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.sf.carte&lt;/groupId&gt;
    &lt;artifactId&gt;css4j&lt;/artifactId&gt;
    &lt;version&gt;${css4j.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</div>
<div class="tema" id="nativedom">
<h2>Using css4j's native DOM implementation</h2>
<p>You can create a DOM document from scratch and use the related DOM methods to programmatically build a document: just use the provided DOM implementation
(<code>io.sf.carte.doc.dom.CSSDOMImplementation</code>). But if you want to parse an existing document, the procedure depends on the type of document: to parse
an XML document (including XHTML documents), you can use this library's <code>XMLDocumentBuilder</code> with the SAX parser provided by the JDK, while to parse
an HTML one (or an XHTML document that does not use namespace prefixes) you can use the <a href="https://about.validator.nu/htmlparser/" target="_blank">validator.nu
HTML5 parser</a> (be sure to use the latest version from the <a href="https://mvnrepository.com/artifact/nu.validator/htmlparser"><code>nu.validator</code>
Maven group id</a>).</p>
<p>An example with that parser follows:</p>
<pre class="code"><code class="language-java">import java.io.Reader;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import io.sf.carte.doc.dom.CSSDOMImplementation;
import io.sf.carte.doc.dom.DOMElement;
import io.sf.carte.doc.dom.HTMLDocument;
import io.sf.carte.doc.dom.XMLDocumentBuilder;
import io.sf.carte.doc.style.css.CSSComputedProperties;
import io.sf.carte.doc.style.css.CSSTypedValue;
import io.sf.carte.doc.style.css.RGBAColor;
import io.sf.carte.doc.xml.dtd.DefaultEntityResolver;
import nu.validator.htmlparser.common.XmlViolationPolicy;
import nu.validator.htmlparser.sax.HtmlParser;
[...]

// Instantiate DOM implementation (with default settings: no IE hacks accepted) 
// and configure it
CSSDOMImplementation impl = new CSSDOMImplementation();
// Alternatively, impl = new CSSDOMImplementation(flags);
// Now load default HTML user agent sheets
impl.setDefaultHTMLUserAgentSheet();

// Prepare parser
HtmlParser parser = new HtmlParser(XmlViolationPolicy.ALTER_INFOSET);
parser.setCommentPolicy(XmlViolationPolicy.ALLOW);
parser.setXmlnsPolicy(XmlViolationPolicy.ALLOW);

// Prepare builder
XMLDocumentBuilder builder = new XMLDocumentBuilder(impl);
builder.setHTMLProcessing(true);
builder.setXMLReader(parser);

// Read the document to parse, and prepare source object
Reader re = ... [reader for HTML document]
InputSource source = new InputSource(re);
// Parse. If the document is not HTML, you want to use DOMDocument instead
HTMLDocument document = (HTMLDocument) builder.parse(source);
re.close();

// Set document URI
document.setDocumentURI("http://www.example.com/mydocument.html");
</code></pre>
<p>Now, you have a CSS-enabled document.</p>
<p>You can see the above code example (and others in this guide) in the <a href="https://github.com/css4j/css4j.github.io/blob/master/src/examples/java/io/sf/carte/example/Css4jTest.java">Css4jTest.java</a>
example file.</p>
<h3 class="subtema" id="computing-styles">Computing styles</h3>
<p>To compute styles, use <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSElement.html#getComputedStyle(java.lang.String)">getComputedStyle</a>:</p>
<pre class="code"><code class="language-java">DOMElement element = document.getElementById("someId");
CSSComputedProperties style = element.getComputedStyle(null);

// Next line could be 'String display = style.getDisplay();'
String display = style.getPropertyValue("display");

// If you use a factory that has been set to setLenientSystemValues(false), next
// line may throw an exception if the 'color' property was not specified.
// The default value for lenientSystemValues is TRUE.
RGBAColor color = ((CSSTypedValue) style.getPropertyCSSValue("color")).toRGBColor();

// Suppose that the linked style sheet located at 'css/sheet.css' declares:
// background-image: url('foo.png');

String image_css = style.getPropertyValue("background-image");
String image_uri = ((CSSTypedValue) style.getPropertyCSSValue("background-image")).getStringValue();

// Then, because we already set the document URI to "http://www.example.com/mydocument.html",
// image_css will be set to "url('http://www.example.com/css/foo.png')",
// and image_uri to "http://www.example.com/css/foo.png"
</code></pre>
<p>The <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSComputedProperties.html">CSSComputedProperties</a>
interface extends W3C's <a href="https://www.w3.org/TR/cssom-1/#the-cssstyledeclaration-interface" target="_blank"><code>CSSStyleDeclaration</code></a>
for computed styles, adding methods like <code>getComputedFontSize()</code> or <code>getComputedLineHeight()</code>.</p>
<p>If you are computing styles for a specific medium, tell the document about it (see "<a href="#mediahandling">Media Handling</a>"):</p>
<pre class="code"><code class="language-java">document.setTargetMedium("print");
</code></pre>
<h3 class="subtema" id="conformance">Conformance with the DOM specification</h3>
<p>This library's native DOM implementation has some minor behavior differences with what is written in the <a href="https://www.w3.org/TR/DOM-Level-3-Core/" target="_blank">DOM
Level 3 Core Specification</a>. For example, on elements and attributes the <code>Node.getLocalName()</code> method returns the tag name instead of
<code>null</code> when the node was created with a DOM Level 1 method such as <code>Document.createElement()</code>. Read the
<a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/dom/package-summary.html">io.sf.carte.doc.dom</a> package
description for additional information.</p>
</div>
<div class="tema" id="dom4j">
<h2>Examples with DOM4J</h2>
<p>To use the library with dom4j (using dom4j-like documents, elements and factory) you need the
<a href="https://github.com/css4j/css4j-dom4j">css4j-dom4j module</a> in addition to the core
module. The -dom4j module optionally depends on the <a href="https://github.com/css4j/css4j-agent">-agent module</a>,
but you do not need the latter unless you plan to use the DOM4J agent.</p>
<p>For example, with Gradle:</p>
<pre class="code"><code class="language-groovy">dependencies {
    api "io.sf.carte:css4j-dom4j:${css4jDom4jVersion}"
}
</code></pre>
<p>or with Apache Maven:</p>
<pre class="code"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.sf.carte&lt;/groupId&gt;
    &lt;artifactId&gt;css4j-dom4j&lt;/artifactId&gt;
    &lt;version&gt;${css4jDom4j.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>The <code>css4j-dom4j</code> artifact transitively implies the <code>css4j</code> core module, but since both artifacts have
different release cycles you may want to add an explicit dependency for the core module, with the latest version.</p>
<p>As explained in the <a href="#modules">modules section</a>, recent <code>css4j-dom4j</code> artifacts are compatible with <code>css4j</code>
artifacts that have the same major version number, for example both <code>css4j-dom4j</code> 3.5.2 and 3.6.0 are compatible with
<code>css4j</code> 3.7.0.</p>
<h3 class="subtema" id="dom4j-parsing">Loading and parsing an XML document</h3>
<p>This is the easiest way to parse an XML document to use this package with DOM4J, using that library's <code>SAXReader</code>:</p>
<pre class="code"><code class="language-java">SAXReader reader = new SAXReader(XHTMLDocumentFactory.getInstance());
reader.setEntityResolver(new DefaultEntityResolver());
Reader re = ... [reader for HTML document]
XHTMLDocument document = (XHTMLDocument) reader.read(re);
</code></pre>
<p>As you see, a document factory called <a class="codeitem" href="api/latest/io.sf.carte.css4j.dom4j/io/sf/carte/doc/dom4j/XHTMLDocumentFactory.html">XHTMLDocumentFactory</a>
is used.</p>
<p>Once you got the element you want the computed style for (see, for example, the
<a href="https://github.com/dom4j/dom4j/wiki/Quick-Start-Guide" target="_blank">DOM4J Quick Start Guide</a>), just get it with a procedure analogous to the
<a href="https://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/css.html#CSS-ViewCSS" target="_blank"><code>ViewCSS</code></a>
interface:</p>
<pre class="code"><code class="language-java">CSSComputedProperties style = ((CSSStylableElement) element).getComputedStyle(null);
String display = style.getPropertyValue("display");
</code></pre>
<p>Be careful to have the <code>XHTMLDocumentFactory</code> loaded with the desired defaults, like the user agent style sheet
which was loaded by default in 1.0 but not in 2.0 and later.</p>
<p>It is also possible to parse an HTML5 document into a css4j-dom4j tree with the aforementioned validator.nu HTML5 parser:</p>
<pre class="code"><code class="language-java">XHTMLDocumentFactory factory = XHTMLDocumentFactory.getInstance();
// Next line is optional: default is TRUE, and is probably what you want
// factory.getStyleSheetFactory().setLenientSystemValues(false);
HtmlParser parser = new HtmlParser(XmlViolationPolicy.ALTER_INFOSET);
parser.setCommentPolicy(XmlViolationPolicy.ALLOW);
parser.setXmlnsPolicy(XmlViolationPolicy.ALLOW);

// Configure the SAXReader with the HtmlParser
SAXReader builder = new SAXReader(factory);
builder.setXMLReader(parser);
// Provide an error handler to avoid exceptions
ErrorHandler errorHandler = [...]
builder.setErrorHandler(errorHandler);

// We do not set the EntityResolver, the HtmlParser does not need it
Reader re = ... [reader for HTML document]
XHTMLDocument document = (XHTMLDocument) builder.read(re);
</code></pre>
<p>Or parse the document with the css4j's builder,
<a href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/dom/XMLDocumentBuilder.html"><code>XMLDocumentBuilder</code></a> (which can account for things like implied HTML parent elements),
instead of dom4j's <a href="https://dom4j.github.io/javadoc/2.1.1/org/dom4j/io/SAXReader.html"><code>SAXReader</code></a>:</p>
<pre class="code"><code class="language-java">XHTMLDocumentFactory factory = XHTMLDocumentFactory.getInstance();
// Next line is optional: default is TRUE, and is probably what you want
// factory.getStyleSheetFactory().setLenientSystemValues(false);

HtmlParser parser = new HtmlParser(XmlViolationPolicy.ALTER_INFOSET);
parser.setCommentPolicy(XmlViolationPolicy.ALLOW);
parser.setXmlnsPolicy(XmlViolationPolicy.ALLOW);

XMLDocumentBuilder builder = new XMLDocumentBuilder(factory);
builder.setHTMLProcessing(true);
builder.setXMLReader(parser);

Reader re = ... [reader for XML document]
InputSource source = new InputSource(re);
XHTMLDocument document = (XHTMLDocument) builder.parse(source);
re.close();
</code></pre>
<h3 class="subtema" id="html-caveats">Caveats about DOM4J and HTML</h3>
<p>A plain HTML document may contain <code>STYLE</code> elements with selectors like <code>div&gt;p</code>,
and css4j's native DOM handles that correctly. However, XML-oriented DOM implementations are likely to serialize
them as "<code>div&amp;gt;p</code>", breaking the CSS. For example, if you serialize a DOM4J document
with <code>asXML()</code> or code like the following:</p>
<pre class="code"><code class="language-java">Writer wri = ... [put your writer here]
OutputFormat format = OutputFormat.createPrettyPrint();
format.setXHTML(true);
HTMLWriter writer = new HTMLWriter(wri, format);
writer.write(document);
</code></pre>
<p>The result will be the "<code>div&amp;gt;p</code>". As explained below, with other DOM implementations
it is possible to work around this problem if one serializes to XHTML with a <a href="#serial-xml-html">properly
configured <code>Transformer</code></a>, but not with DOM4J.</p>
</div>
<div class="tema" id="domwrapper">
<h2>Usage with the DOM wrapper</h2>
<p>If you choose to build your document with your favorite DOM implementation instead of the CSS4J one or the DOM4J back-end, you can use the
<a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/DOMCSSStyleSheetFactory.html#createCSSDocument(org.w3c.dom.Document)">DOMCSSStyleSheetFactory.createCSSDocument(document)</a>
method to wrap a pre-existing DOM Document. Example:</p>
<pre class="code"><code class="language-java">DOMCSSStyleSheetFactory cssFactory = new DOMCSSStyleSheetFactory();
CSSDocument document = cssFactory.createCSSDocument(otherDOMdocument);
</code></pre>
<p>Unlike the native DOM or the DOM4J back-end, the DOM resulting from the DOM wrapper is read-only, although you can change the
values of some nodes.</p>
<h3 class="subtema" id="serial-xml-html">Serializing HTML with an XML DOM</h3>
<p>As was <a href="#html-caveats">previously mentioned</a>, if you serialize a plain HTML document
(which does not contain <code>CDATA</code> sections) with an XML-oriented DOM, you can avoid serializing
<code>div&gt;p</code> as "<code>div&amp;gt;p</code>" if you use a <code>Transformer</code> which is
configured for the task. The code would be like the following:</p>
<pre class="code"><code class="language-java">TransformerFactory tf = TransformerFactory.newInstance();
Transformer transformer = tf.newTransformer();
transformer.setOutputProperty(OutputKeys.METHOD, "xml");
// Put other Transformer configurations here
// ...
transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
// Put the embedded style sheets inside <code>CDATA</code> sections
transformer.setOutputProperty(OutputKeys.CDATA_SECTION_ELEMENTS, "script style");

Writer wri = ... [put your writer here]
transformer.transform(new DOMSource(document), new StreamResult(wri));
</code></pre>
<p>which —as the comment says— puts the embedded style sheets inside <code>CDATA</code> sections.
Note, however, that:</p>
<ol>
<li>In HTML, the
<a href="https://html.spec.whatwg.org/multipage/syntax.html#cdata-sections">CDATA sections can only be used in foreign content</a>
—otherwise being considered as "bogus comments"— so you are now in XHTML instead of HTML.</li>
<li>If you use the above code with css4j-dom4j (3.6.1 or later is required), it will not produce
the desired result.</li>
</ol>
<p>To handle HTML, the <a href="https://css4j.github.io/api/latest/io.sf.carte.css4j/io/sf/carte/doc/dom/package-summary.html">native DOM</a>
is recommended over any XML DOM.</p>
</div>
<div id="dom-impls-diff" class="tema">
<h2>Consistency of different DOM implementations</h2>
<p>Beware that the computed styles found by each method (native DOM, DOM4J back-end or DOM wrapper) may not be completely identical, due to differences in the
underlying document DOM implementations:</p>
<ul>
<li>XML-oriented DOM implementations do not implement the case sensitivity subtleties of HTML (although this library attempts to emulate the basics).</li>
<li>The <code>:dir()</code> pseudo-class is not fully supported on DOM4J, due to limitations in its DOM support.</li>
</ul>
<p>If you find a difference in styles computed from different back-ends that you believe to be a bug, please report it.</p>
</div>
<div class="tema" id="declared-styles">
<h2>Accessing the declared style sheets</h2>
<h3 class="subtema" id="cssom-indexed-access">CSSOM indexed access</h3>
<p>To access the styles declared in style sheets, we can use the relevant
<a href="https://www.w3.org/TR/cssom-1/" target="_blank">CSS Object Model</a> methods.
For example, suppose that the first style sheet of the document contains only the following rule:</p>
<pre class="code"><code class="language-css">div > .myClass {
  font-size: 14pt;
  color: var(--myColor, #46f);
}
</code></pre>
<p>then, to access that style sheet and that rule we could use something like this:</p>
<pre class="code"><code class="language-java">/*
 * Access style sheet(s) and its rule(s)
 */
// Obtain the list of CSS style sheets
StyleSheetList sheets = document.getStyleSheets();
// Access the first sheet
AbstractCSSStyleSheet sheet = sheets.item(0);
// The first rule in the sheet
AbstractCSSRule rule = sheet.getCssRules().item(0);
// What kind of rule is it?
int ruleType = rule.getType();
// It is a style rule (CSSRule.STYLE_RULE)
</code></pre>
<p>Now we can cast to a <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/StyleRule.html">StyleRule</a>
which gives us access to the selector list and the declared style.</p>
<h3 class="subtema" id="rule-iterators">Rule iterators</h3>
<p>The same as above, but with a rule iterator:</p>
<pre class="code"><code class="language-java">/*
 * It is possible to use iterators to retrieve the rules.
 */
sheet = sheets.item(0);
Iterator<AbstractCSSRule> it = sheet.getCssRules().iterator();
// Assume it.hasNext() returns true

// Access the first rule in the sheet
rule = it.next();
// What kind of rule is it?
ruleType = rule.getType();
// It is a style rule (CSSRule.STYLE_RULE)
</code></pre>
<h3 class="subtema" id="sheet-visitors">Sheet Visitors</h3>
<p>You can also use the <a class="codeitem" href="api/latest/io.sf.carte.util/io/sf/carte/util/Visitor.html">Visitor</a>
API to perform many of the tasks that can be achieved with the standard CSSOM, for example:</p>
<ul>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/AbstractCSSStyleSheet.html#acceptStyleRuleVisitor(io.sf.carte.util.Visitor)">acceptStyleRuleVisitor</a>
 to visit style rules in a sheet.</li>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/AbstractCSSStyleSheet.html#acceptDeclarationRuleVisitor(io.sf.carte.util.Visitor)">acceptDeclarationRuleVisitor</a>
 to visit declaration rules in a sheet. In the terminology of this library, a declaration rule is a rule that
contains any kind of declaration, be it property or descriptor declarations. For example, style, font-face and
keyframe rules are all "declaration rules".</li>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/AbstractCSSStyleSheet.html#acceptDescriptorRuleVisitor(io.sf.carte.util.Visitor)">acceptDescriptorRuleVisitor</a>
 to visit declaration rules with descriptors within a sheet.</li>
</ul>
<p>Those methods also apply to sheet lists:</p>
<ul>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheetList.html#acceptStyleRuleVisitor(io.sf.carte.util.Visitor)">acceptStyleRuleVisitor</a>
 to visit style rules in a list of sheets.</li>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheetList.html#acceptDeclarationRuleVisitor(io.sf.carte.util.Visitor)">acceptDeclarationRuleVisitor</a>
 to visit declaration rules in a list of sheets.</li>
<li><a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheetList.html#acceptDescriptorRuleVisitor(io.sf.carte.util.Visitor)">acceptDescriptorRuleVisitor</a>
 to visit declaration rules with descriptors within a list of sheets.</li>
</ul>
<p>With Visitors, you do not need to navigate the different rules yourself. For an example of its use, see <a
href="embed-svg.html">Embedding SVG in HTML documents</a>.</p>
<h3 class="subtema" id="selectors">Dealing with selectors</h3>
<p>If your use case requires inspecting the selectors, you will need to look at the NSAC api, starting with the
<a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/nsac/Selector.html">Selector</a> class.</p>
<pre class="code"><code class="language-java">// Cast
StyleRule styleRule = (StyleRule) rule;
// Obtain the selector list
SelectorList selist = styleRule.getSelectorList();

// First (and only) selector
Selector selector = selist.item(0);
// Selector type (which we can use to cast the selector)
SelectorType selType = selector.getSelectorType();
// For "div > .myClass" selType would be SelectorType.CHILD

// Cast to CombinatorSelector (see CHILD javadoc)
CombinatorSelector comb = (CombinatorSelector) selector;
// Obtain the two selectors that are combined by ">"
Selector firstSel = comb.getSelector();
SimpleSelector secondSel = comb.getSecondSelector();

// Examine the first selector
SelectorType firstSelType = firstSel.getSelectorType();
// Type is SelectorType.ELEMENT (div)

// Cast to ElementSelector (see ELEMENT javadoc)
ElementSelector elemSel = (ElementSelector) firstSel;
String elemName = elemSel.getLocalName();
// It is "div"

// Now the second selector
SelectorType secondSelType = secondSel.getSelectorType();
// Type is SelectorType.CONDITIONAL (.myClass)

// Cast to ConditionalSelector
ConditionalSelector condSel = (ConditionalSelector) secondSel;
Condition condition = condSel.getCondition();
ConditionType condType = condition.getConditionType();
// The condition type is ConditionType.CLASS

// Cast condition to AttributeCondition (as suggested by the CLASS javadoc)
AttributeCondition attrCond = (AttributeCondition) condition;
// Retrieve the condition (class) name
String cssClassName = attrCond.getValue();
// It is "myClass"
</code></pre>
<h4 class="subtema4" id="nsac-selectors">Low-level selector parsing</h4>
<p>
Sometimes one has to work with stand-alone selectors, for which you can use a NSAC parser:
</p>
<pre class="code"><code class="language-java">CSSParser parser = new CSSParser();
SelectorList selist = parser.parseSelectors("a:not([href]):not([tabindex]):focus,pre,.myClass span");
</code></pre>
<p><em>
Note: you should avoid stand-alone parsing namespaced selectors with <a class="codeitem"
href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/parser/CSSParser.html#parseSelectors(java.io.Reader)">parseSelectors</a>
and equivalent single-argument methods in <code>CSSParser</code>, as the namespace prefixes
won't map to any namespace URI. See <a class="codeitem"
href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/parser/CSSParser.html#parseSelectors(java.lang.String,io.sf.carte.doc.style.css.nsac.Parser.NamespaceMap)"
>parseSelectors(String,Parser.NamespaceMap)</a> for a solution to the issue.</em></p>
<h3 class="subtema" id="use-declared-styles">Using the declared styles</h3>
<p>In the previous example we got the style rule in a <code>styleRule</code> variable.
Now we use it to obtain the declared style with <a class="codeitem"
href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSDeclarationRule.html#getStyle()">getStyle()</a>
and examine the declared properties:</p>
<pre class="code"><code class="language-java">// Obtain the declared style from the rule
AbstractCSSStyleDeclaration style = styleRule.getStyle();

// Obtain the number of properties
int pCount = style.getLength();
// Two properties

/*
 * The first property
 */
// Retrieve the name of the first property
String pname0 = style.item(0);
// pname0 is "font-size"

// Obtain the value of "font-size"
StyleValue fontSize = style.getPropertyCSSValue("font-size");

// Is it a length?
SyntaxParser synparser = new SyntaxParser();
CSSValueSyntax syntaxLength = synparser.parseSyntax("&lt;length&gt;");
Match match0 = fontSize.matches(syntaxLength);
// Match.TRUE: yes it is a length

// Let's check the primitive type
CSSValue.Type primiType0 = fontSize.getPrimitiveType();
// CSSValue.Type.NUMERIC: It is numeric

// Obtain the CSS unit and numeric value
NumberValue numericValue = (NumberValue) fontSize;
short unit = numericValue.getUnitType();
// Unit is typographic points (CSSUnit.CSS_PT)
float floatVal = numericValue.getFloatValue(unit);
// Value is 14 (14pt)

// Change the value to 23px (could use any length unit)
numericValue.setFloatValue(CSSUnit.CSS_PX, 23f);

/*
 * The second property
 */
// Retrieve the name of the second property
String pname1 = style.item(1);
// pname1 is "color"

// Obtain the value of "color"
StyleValue color = style.getPropertyCSSValue("color");

// Let's check the global type
CSSValue.CssType type1 = color.getCssValueType();
// It is a CSSValue.CssType.PROXY, which means that it is either a
// custom property value (it is not) or a type not known in advance

// But may it be a color?
CSSValueSyntax syntaxColor = synparser.parseSyntax("&lt;color&gt;");
Match match1 = color.matches(syntaxColor);
// Gives Match.PENDING: yes it could be a color, but we do not know for sure
// until the value is computed

// Check the primitive type
CSSValue.Type primiType1 = color.getPrimitiveType();
// It is a var() function (CSSValue.Type.VAR)

// Obtain the custom property name
VarValue varValue = (VarValue) color;
String customPropertyName = varValue.getName();
// Name is --myColor

// In this case we have a fallback value (otherwise next line returns null)
LexicalUnit lexUnit = varValue.getFallback();
// Let's see its unit type
LexicalType luType = lexUnit.getLexicalUnitType();
// It is a LexicalType.RGBCOLOR

// And the color is...
String strColor = lexUnit.getCssText();
// Is '#46f'

// Access the individual color components.
// RGB colors are accessed as a rgb() function, so we retrieve
// the function parameters as a doubly-linked list:
LexicalUnit firstComponent = lexUnit.getParameters();

// Let's see the lexical type to see how we access the value
LexicalType firstLexUnitType = firstComponent.getLexicalUnitType();
// It is a LexicalType.INTEGER (RGB components could be REAL and PERCENTAGE as well)

// Therefore we use getIntegerValue()
int color_R = firstComponent.getIntegerValue();
// Is 0x44 hex (68 decimal)

// Second component is the next in the linked list.
// Beware that if the color was specified with commas,
// like "rgb(68, 102, 255)", the next one could be a comma!
LexicalUnit secondComponent = firstComponent.getNextLexicalUnit();
int color_G = secondComponent.getIntegerValue();
// Is 0x66 (102 decimal)

// Third component
LexicalUnit thirdComponent = secondComponent.getNextLexicalUnit();
int color_B = thirdComponent.getIntegerValue();
// Is 0xff (255 decimal)
</code></pre>
<p>Now let's set another property using <a class="codeitem"
href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleDeclaration.html#setProperty(java.lang.String,java.lang.String,java.lang.String)">setProperty</a>:</p>
<pre class="code"><code class="language-java">/*
 * Set another property, with important priority
 */
style.setProperty("background-color", "#d0dfee7a", "important");

pCount = style.getLength();
// Now we have three properties
</code></pre>
<p>If you are updating any of the declared sheets —that is, the sheets returned by <code>document.getStyleSheets()</code>—
with <code>setProperty</code> while you are computing styles, the changes will not apply to the computed styles
until you update the cascade with a call to <a class="codeitem"
href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSDocument.html#rebuildCascade()">rebuildCascade()</a>.</p>
<h3 class="subtema" id="update-internal-sheets">Updating internal sheets</h3>
<p><b>IMPORTANT:</b> once we are done updating a style sheet, if the sheet is internal to the
document (that is, it is located inside a <code>&lt;style&gt;</code> element), the actual
contents of the <code>&lt;style&gt;</code> element will not be updated until you execute
<code>normalize()</code> on that element node:</p>
<pre class="code"><code class="language-java">// Obtain the owner node
org.w3c.dom.Node styleNode = sheet.getOwnerNode();

// Which type is it?
short nodeType = styleNode.getNodeType();
// It is a ELEMENT_NODE (could also be a PROCESSING_INSTRUCTION_NODE)

// Get the name of the element
String nodeName = styleNode.getNodeName();
// It is "style", as expected

// Get the element content (the initial serialized style sheet)
String preContent = styleNode.getTextContent();

// Serialize the current style sheet into the inner text node
styleNode.normalize();

// Get the normalized element content (the current serialization)
String afterContent = styleNode.getTextContent();
// preContent and afterContent are different
</code></pre>
</div>
<div class="tema" id="inline-styles">
<h2>Working with inline styles</h2>
<p>Now we are going to obtain the inline style of an element, as given by the <code>style</code> attribute.
In the next example, the inline style is supposed to contain the declaration of a custom property called
<code>--myColor</code> with a value <code>#54e</code>.</p>
<pre class="code"><code class="language-java">/*
 * Access a style attribute (inline styles)
 */
// First obtain the desired element, for example:
CSSElement element = document.getElementById("someId");
// Now the inline style. It can be directly accessed
CSSStyleDeclaration inlineStyle = element.getStyle();

// How many properties are defined?
int inlinePCount = inlineStyle.getLength();
// Suppose that it is just one called --myColor

// Retrieve its name
String inlinePname0 = inlineStyle.item(0);
// It is "--myColor"

// Now get the value
CSSValue myColor = inlineStyle.getPropertyCSSValue(inlinePname0);

/*
 * Handle the custom property in myColor
 */
// Get the general value type
CSSValue.CssType type = myColor.getCssValueType();
// Being a custom property, it must be a CssType.PROXY

// But is it (or could be) a color?
Match matchCP = myColor.matches(syntaxColor);
// Match.TRUE: Yes it is for sure!

// Let's see the primitive type, although...
CSSValue.Type primiType = myColor.getPrimitiveType();
// custom properties are *always* Type.LEXICAL values

LexicalValue lvColor = (LexicalValue) myColor;
// Can we know its final value type once it is processed?
Type finalType = lvColor.getFinalType();
// Yes, as suggested by the result of calling 'matches'
// ...it is a Type.COLOR

// Let's retrieve its value
LexicalUnit lexUnitCP = lvColor.getLexicalUnit();
// First see its unit type
LexicalType luTypeCP = lexUnitCP.getLexicalUnitType();
// It is a RGBCOLOR

// And the color is...
String strlexUnitCP = lexUnitCP.getCssText();
// Is '#54e'. We could also access its components

// Let's change the value of the custom property
// We want to set '#667'
inlineStyle.setProperty(inlinePname0, "#667", null);

// Check that we successfully assigned the new value:
String newInlineValue = inlineStyle.getPropertyValue(inlinePname0);
// Yes it is '#667' as we wanted
</code></pre>
<p>After changing an inline style you do not need to call any method (like how <code>normalize()</code> was used for
internal sheets) to modify the document. The serialization of (inline) style attributes is always up to date.</p>
<p>The small drawback is that the <code>style</code> attributes may not appear exactly as they were specified, but instead
according to the serialization given by this library (which can be tailored a bit, for example by customizing <a class="codeitem"
href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/StyleFormattingContext.html#endInlinePropertyDeclaration(io.sf.carte.util.SimpleWriter)"
>endInlinePropertyDeclaration()</a> in your own <code>StyleFormattingContext</code>, see <a href="#styleformatting">CSS
style formatting</a> for details).</p>
</div>
<div class="tema" id="overridestyles">
<h2>Override styles</h2>
<p>Override styles, that come after the author style sheet in the cascade algorithm, are not part of the formal standard
but are supported by this library; they are like "hidden" inline styles.</p>
<p>To access the override style of an element, use <code>CSSElement</code>'s <a class="codeitem"
href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSElement.html#getOverrideStyle(io.sf.carte.doc.style.css.nsac.Condition)">getOverrideStyle</a>.
For example:</p>
<pre class="code"><code class="language-java">element.getOverrideStyle(null).setCssText("padding: 6pt;");
</code></pre>
<p>Override styles are defined at the <a href="https://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/css.html#CSS-DocumentCSS" target="_blank">DocumentCSS interface</a> description.</p>
</div>
<div id="cascade" class="tema">
<h2>Configuring the cascade</h2>
<p>Depending on your use case, you may need to set the <a href="https://www.w3.org/TR/css-cascade-3/#origin">user
agent (UA) style sheet</a> before starting to compute styles.
The library supports two different UA sheets, one for <code>STRICT</code> ('standards') mode and another for <code>QUIRKS</code>.
To set either of those sheets, first obtain an instance of the factory that you are using:
</p>
<pre class="code"><code class="language-java">// Instantiate the new factory or get it from an object that you are already using.
AbstractCSSStyleSheetFactory cssFactory = ...
</code></pre>
<p>If you are using the DOM4J classes, you may want to do:</p>
<pre class="code"><code class="language-java">AbstractCSSStyleSheetFactory cssFactory = XHTMLDocumentFactory.getInstance().getStyleSheetFactory();
</code></pre>
<p>If you are processing HTML, css4j's default HTML5 UA sheet (based on W3C/WHATWG recommendations) should be
appropriate for you:
</p>
<pre class="code"><code class="language-java">cssFactory.setDefaultHTMLUserAgentSheet();
</code></pre>
<p>But if you want to set your own UA sheet, first obtain a reference to the sheet:</p>
<pre class="code"><code class="language-java">BaseCSSStyleSheet sheet = cssFactory.getUserAgentStyleSheet(CSSDocument.ComplianceMode.STRICT);
</code></pre>
<p>This is assuming the <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSDocument.ComplianceMode.html#STRICT">STRICT</a>
mode, <i>i.e.</i> that you use documents with a <code>DOCTYPE</code>, otherwise use <code>QUIRKS</code> (or you may want to set both UA sheets).
</p>
<p>If the UA sheet already contains rules (it is empty by default), clean it:</p>
<pre class="code"><code class="language-java">sheet.getCssRules().clear();
</code></pre>
<p>And now load the new sheet:</p>
<pre class="code"><code class="language-java">Reader reader = ... [reads the UA sheet]
sheet.parseStyleSheet(reader, CSSStyleSheet.COMMENTS_IGNORE);
reader.close();
</code></pre>
<p>As the UA sheet's comments are rarely of interest at the OM level, they were ignored during the parse
process (notice the <code>COMMENTS_IGNORE</code> flag).</p>
<p><em>Note: this implementation does not support <code>important</code> style declarations in the UA sheet.</em></p>
<h3 class="subtema" id="user-style-sheet">Setting the user style sheet</h3>
<p>There is also the possibility to set a user style sheet (with 'user' origin) via <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheetFactory.html#setUserStyleSheet(java.io.Reader)">setUserStyleSheet</a>:</p>
<pre class="code"><code class="language-java">Reader reader = ... [reads the user sheet]
cssFactory.setUserStyleSheet(reader);
reader.close();
</code></pre>
<p>Both <code>important</code> and normal declarations are supported in the <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheetFactory.html#ORIGIN_USER">user</a> style sheet.</p>
</div>
<div class="tema" id="mediahandling">
<h2>Media handling</h2>
<h3 class="subtema" id="setting-target-medium">Setting a target medium for computed styles</h3>
<p>By default, computed styles only take into account generic styles that are common to all media. If you want to target a more specific medium,
you have to use the <code>CSSDocument.setTargetMedium("<i>medium</i>")</code> method. For example, if your document has the following style sheets linked:</p>
<pre class="code"><code class="language-xml">&lt;link href="http://www.example.com/css/sheet.css" rel="stylesheet" type="text/css" /&gt;
&lt;link href="http://www.example.com/css/sheet_for_print.css" rel="stylesheet" media="print" type="text/css" /&gt;
</code></pre>
<p>Computed styles will initially take into account only the "sheet.css" style sheet. However, if you execute the following method:</p>
<pre class="code"><code class="language-java">document.setTargetMedium("print");
</code></pre>
<p>Then all subsequently computed styles will account for the merged style sheet from "sheet.css" and "sheet_for_print.css".</p>
<p>This way to tie a document with a medium is not totally standard, as the W3C APIs would probably expect a <code>DeviceFactory</code>-related object implementing the
<a href="https://www.w3.org/2003/01/dom2-javadoc/org/w3c/dom/css/ViewCSS.html" target="_blank"><code>ViewCSS</code></a> interface and referencing the document,
but this approach allows to isolate DOM logic inside DOM objects and keep the <code>DeviceFactory</code> for media-specific information only.</p>
<h3 class="subtema" id="media-queries">Media queries</h3>
<p>The library provides an object-oriented interface to access media queries. If you obtain a <a class="codeitem"
href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/MediaQueryList.html">MediaQueryList</a> from a style
sheet or a factory object, you can handle it like in the following example, where we create a media query
and then produce a style sheet tied to it:</p>
<pre class="code"><code class="language-java">// We instantiate a factory based on CSSDOMImplementation,
// but could do the same with any of the other factories
AbstractCSSStyleSheetFactory cssFactory = new CSSDOMImplementation();

/*
 * Parsing a Media Query
 */
MediaQueryList mql = cssFactory.createMediaQueryList("screen and (600px <= width < 1200px)",
	null);

// How many queries we got?
int numQueries = mql.getLength();
// One

// Get the first and only query
MediaQuery mediaQ = mql.getMediaQuery(0);

// The media type
String medium = mediaQ.getMediaType();
// It is "screen"

/*
 * Have a look at the associated boolean condition(s)
 */
BooleanCondition cond = mediaQ.getCondition();

// The condition type
BooleanCondition.Type condType = cond.getType();
// It is BooleanCondition.Type.AND

// As the AND javadoc suggests, call getSubConditions()
List<BooleanCondition> andConds = cond.getSubConditions();
// andConds.size() is 2

// The first operand of the AND
BooleanCondition cond1 = andConds.get(0);
// The condition type
BooleanCondition.Type cond1Type = cond1.getType();
// It is BooleanCondition.Type.PREDICATE

// Now, following the indication from the getCondition() javadoc
// we cast the predicate to a MediaQueryPredicate
MediaQueryPredicate predicate1 = (MediaQueryPredicate) cond1;
// predicate1.getPredicateType() is MediaQueryPredicate.MEDIA_TYPE
// predicate1.getName() is "screen"

// The second operand of the AND
BooleanCondition cond2 = andConds.get(1);
// The condition type
BooleanCondition.Type cond2Type = cond2.getType();
// It is BooleanCondition.Type.PREDICATE

// Again, following the indication from the getCondition() javadoc
// we cast the predicate to a MediaQueryPredicate
MediaQueryPredicate predicate2 = (MediaQueryPredicate) cond2;
// predicate2.getPredicateType() is MediaQueryPredicate.MEDIA_FEATURE
// predicate2.getName() is "width"

// Cast predicate2 to MediaFeature
MediaFeature feature = (MediaFeature) predicate2;
// feature.getRangeType() is MediaFeaturePredicate.FEATURE_LE_AND_LT

// Obtain the first value in the LE_AND_LT range
CSSTypedValue value = feature.getValue();
// value.getPrimitiveType() is Type.NUMERIC
// value.getUnitType() is CSSUnit.CSS_PX (pixels)

// Get the numeric value
float floatValue = value.getFloatValue(CSSUnit.CSS_PX);
// Value is 600 (px)

// Now the second value in the LE_AND_LT range
CSSTypedValue value2 = feature.getRangeSecondValue();
// value.getPrimitiveType() is Type.NUMERIC
// value.getUnitType() is CSSUnit.CSS_PX

// Get the numeric value
float floatValue2 = value2.getFloatValue(CSSUnit.CSS_PX);
// Value is 1200 (px)

// Finally, create a sheet attached to that query
AbstractCSSStyleSheet sheet = cssFactory.createStyleSheet(null, mql);

// The object returned by 'sheet.getMedia()' and the 'mql' variable
// would be the same one
</code></pre>
</div>
<div class="tema" id="sheetsets">
<h2>Style sheet sets</h2>
<p>The library supports alternative style sheets: see CSSDocument's methods
<a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSDocument.html#enableStyleSheetsForSet(java.lang.String)">enableStyleSheetsForSet</a>,
getStyleSheetSets, getSelectedStyleSheetSet and setSelectedStyleSheetSet. For example, if you have a document with these linked sheets:</p>
<pre class="code"><code class="language-xml">&lt;link href="http://www.example.com/commonsheet.css" rel="stylesheet" type="text/css" /&gt;
&lt;link href="http://www.example.com/alter1.css" rel="alternate stylesheet" type="text/css" title="Alter 1" /&gt;
&lt;link href="http://www.example.com/alter2.css" rel="alternate stylesheet" type="text/css" title="Alter 2" /&gt;
&lt;link href="http://www.example.com/default.css" rel="stylesheet" type="text/css" title="Default" /&gt;
</code></pre>
<p>Initially, sheets 'alter1.css' and 'alter2.css' will not be used to compute styles. But then you can write code like the following:</p>
<pre class="code"><code class="language-java">String defset = document.getSelectedStyleSheetSet();  // Sets 'defset' to "Default"
document.setSelectedStyleSheetSet("Alter 1");  // Selects the set with title "Alter 1"
document.setSelectedStyleSheetSet("Alter 2");  // Selects the set with title "Alter 2"
</code></pre>
<p>These methods have been removed from the DOM standard unfortunately, but you can still read the specification at the <a href="https://www.w3.org/TR/2013/WD-cssom-20131205/#extensions-to-the-document-interface" target="_blank">CSSOM 5 December 2013 Working Draft</a>.</p>
</div>
<div class="tema" id="errorchecking">
<h2>Style sheet error checking</h2>
<p>You can check for errors and warnings in the document's sheets using the non-standard
<a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheet.html#getErrorHandler()">getErrorHandler</a> method. Example:</p>
<pre class="code"><code class="language-java">if (document.getStyleSheets().item(0).getErrorHandler().hasSacErrors())
	... error processing / reporting
</code></pre>
<p>The merged style sheet obtained from the <code>getStyleSheet</code> method has the merged error/warning state from the document's active sheets.</p>
<p>A typical source of errors are the non-compliant IE hacks, like prefixing property names with an asterisk (you may want to use the proper
NSAC flags when creating the factory, see <a href="#legacycompat">Compatibility with legacy browsers</a>),
or charset rules found in the wrong place.</p>
</div>
<div class="tema" id="sheetparsing">
<h2>Parsing a style sheet</h2>
<p>Although document's style sheet fetching and parsing is automatic with this library (for sheets referenced from a document), it is possible to manually parse rules
from a source stream with the <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheet.html#parseStyleSheet(java.io.Reader,short)">CSSStyleSheet.parseStyleSheet(Reader, short)</a> method:</p>
<pre class="code"><code class="language-java">Reader re = ...
sheet.parseStyleSheet(re, CSSStyleSheet.COMMENTS_AUTO);
</code></pre>
<p>When the second argument is <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheet.html#COMMENTS_IGNORE">COMMENTS_IGNORE</a>, the comments in the source stream are ignored when parsing
(see <a href="#sheetcomments"><em>Accessing Style Sheet Comments</em></a>).</p>
<p>Important notes:</p>
<ul>
<li>Parsing a style sheet won't produce a <code>DOMException</code> unless the error handler (which you can
customize) does raise it.</li>
<li><p>The new CSS rules found in the source stream are added to the already present ones, <em>i.e.</em> the sheet is not reset by this method
(although the error handler is), so if you want to refill a sheet you need to clear the rules before parsing:</p>
<pre class="code"><code class="language-java">sheet.getCssRules().clear();
</code></pre></li>
</ul>
</div>
<div class="tema" id="securitymodel">
<h2>Security model</h2>
<p>Linked style sheets accessed through DOM are automatically fetched, but if your <code>LINK</code> element or <code>@import</code>
rule point to a <code>file:</code> or <code>jar:</code> URL, the style sheet won't be retrieved unless you set the <code>documentURI</code>
of your document to one of those URIs.</p>
<p>A similar reasoning applies to the contents of the <code>href</code> attribute in the <code>BASE</code> element. If you load a
document that contains a <code>&lt;base href="file:///some/path"&gt;</code>, that won't take effect until you call <code>setDocumentURI()</code>
to set a URI with a <code>file:</code> or <code>jar:</code> scheme. This prevents denial of service attacks that could cause thread starvation
(for example by linking to <code>file:///dev/zero</code>) or deplete the pool of entropy in your server (<code>file:///dev/random</code>),
as well as <code>jar:</code> decompression bombs.</p>
</div>
<div class="tema" id="legacycompat">
<h2>Compatibility with legacy browsers</h2>
<p>Today's style sheets often contain non-conformant styles that target specific versions of old web browsers, like Internet Explorer.
Several web sites contain information about that, including:</p>
<ul>
<li><a href="http://browserhacks.com/" target="_blank">browserhacks.com</a></li>
<li><a href="http://www.webdevout.net/css-hacks" target="_blank">www.webdevout.net/css-hacks</a></li>
</ul>
<p>Although it could be argued whether those hacks should be used or not, the point is that actual style sheets do contain them, so this
library supports them.</p>
<p>By default, a factory is configured to use a flagless NSAC parser which would produce an error on any of those non-standard constructs,
but a set of compatibility flags can be specified in the constructors for the factory implementations. The different flags
are documented in the <a href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/nsac/package-summary.html">NSAC javadocs</a>.</p>
<p>The flags available at the time of this guide's update are the following:</p>
<ul>
<li><code>STARHACK</code>. When set, the parser will handle asterisk-prefixed property names as accepted, normal names.</li>
<li><code>IEVALUES</code> supports values ending with <code>\9</code> or <code>\0</code>, as well as
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter" target="_blank"><i>progid</i> filters</a> and
<a href="https://blogs.msdn.microsoft.com/ie/2008/10/16/ending-expressions/" target="_blank">IE expressions</a>.</li>
<li><code>IEPRIO</code> allows values ending with the <code>'!ie'</code> priority hack.</li>
<li><code>IEPRIOCHAR</code> accepts values with an <code>'!important!'</code> priority hack (note the <code>'!'</code> at the end).</li>
</ul>
<p>The object model manages these compatibility values in parallel to standard ones. For example, after parsing this declaration
with <code>IEVALUES</code> set:</p>
<pre class="code"><code class="language-css">width: 900px; width: 890px\9;
</code></pre>
<p>its serialization would be identical (if the flag was set correctly):</p>
<pre class="code"><code class="language-css">width: 900px; width: 890px\9;
</code></pre>
<p>but the declaration's length shall be only <code>1</code>. And computed styles only use the standard values unless there are
no alternatives (no standard value was set). The workings are similar for <code>IEPRIO</code> and <code>IEPRIOCHAR</code>:</p>
<pre class="code"><code class="language-css">width: 890px !ie;
width: 890px !important!;
</code></pre>
<p>with the last one being handled as of <code>important</code> priority. Values created by <code>IEPRIOCHAR</code> are never used
in computed styles.</p>
<p>Instead, declarations including asterisk-prefixed property names (created by <code>STARHACK</code>) always increase the declaration's
length. For example, the length of the following declaration would be <code>2</code>:</p>
<pre class="code"><code class="language-css">width: 900px;
*width: 890px;
</code></pre>
<p>If you want to use these flags at the NSAC level (instead of the Object Model), you may want to read the 'Parser Flags' section in the
<a href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/nsac/package-summary.html">NSAC package description</a>,
as well as the documentation for the individual flags in <a class="codeitem"
href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/nsac/Parser.Flag.html">Parser.Flag</a>.</p>
</div>
<div class="tema" id="styleformatting">
<h2>CSS style formatting</h2>
<p>The serialization of the <code>cssText</code> attribute in <a href="https://www.w3.org/TR/cssom-1/#dom-cssrule-csstext" target="_blank">rules</a> and
<a href="https://www.w3.org/TR/cssom-1/#dom-cssstyledeclaration-csstext" target="_blank">style declarations</a> can be customized with an implementation
of the <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/StyleFormattingContext.html">StyleFormattingContext</a> interface.
You can set your <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/StyleFormattingFactory.html">StyleFormattingFactory</a>
(which produces your customized formatting context) to the sheet factory with the <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheetFactory.html#setStyleFormattingFactory(io.sf.carte.doc.style.css.StyleFormattingFactory)">CSSStyleSheetFactory.setStyleFormattingFactory</a>
method, or subclass your style sheet factory and override the <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/BaseCSSStyleSheetFactory.html#createDefaultStyleFormattingFactory()">createDefaultStyleFormattingFactory</a> method.</p>
<p>Look at the <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/DefaultStyleFormattingContext.html">DefaultStyleFormattingContext</a>
class for an example of a formatting context implementation.</p>
<p>To customize the serialization of computed styles, you want to override the <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/StyleFormattingFactory.html#createComputedStyleFormattingContext()">createComputedStyleFormattingContext()</a> method.
The convenience <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/RGBStyleFormattingFactory.html">RGBStyleFormattingFactory</a>
serializes computed colors as RGB and may serve as a customization example.</p>
<h3 class="subtema" id="string-value-formatting">String value formatting</h3>
<p>There is also the possibility to customize the default serialization of string values, with the <a href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheetFactory.html#setFactoryFlag(byte)">CSSStyleSheetFactory.setFactoryFlag(byte)</a>
method. You can set two flags that govern which quotation you prefer, or keep the default behaviour:</p>
<ul><li><b>Default:</b> Try to keep the original quotation (single or double quotes), unless the alternative is more efficient.</li>
<li><b><a href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/AbstractCSSStyleSheetFactory.html#STRING_DOUBLE_QUOTE">STRING_DOUBLE_QUOTE</a>:</b>
Use double quotes unless single quotes are more efficient (when the string contains more double quotes than single).</li>
<li><b><a href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/AbstractCSSStyleSheetFactory.html#STRING_SINGLE_QUOTE">STRING_SINGLE_QUOTE</a>:</b>
Use single quotes unless double quotes are more efficient (when the string contains more single quotes than double).</li>
</ul>
</div>
<div class="tema" id="minification">
<h2>Minification</h2>
<p>The library provides methods for minified serialization at different levels (values, declarations, rules, lists, etc)
but one generally wants to work at the style sheet level, in which case a generic CSS minification method could
look like the following:</p>
<pre class="code"><code class="language-java">import io.sf.carte.doc.dom.CSSDOMImplementation;
import io.sf.carte.doc.style.css.CSSStyleSheet;
import io.sf.carte.doc.style.css.nsac.Parser;
import io.sf.carte.doc.style.css.om.AbstractCSSStyleSheet;
import io.sf.carte.doc.style.css.om.AbstractCSSStyleSheetFactory;

public static String minifyCSS(String css) {
    // Instantiate any style sheet factory, with parser flags allowing IE hacks
    AbstractCSSStyleSheetFactory cssFactory = new CSSDOMImplementation(
        EnumSet.allOf(Parser.Flag.class));
    // Create an empty style sheet
    AbstractCSSStyleSheet sheet = cssFactory.createStyleSheet(null, null);
    // Parse and check for return value
    try {
        if (sheet.parseStyleSheet(new StringReader(css),
                CSSStyleSheet.COMMENTS_IGNORE)) {
            // Parsed without errors
            return sheet.toMinifiedString();
        }
    } catch (IOException e) {
        // Cannot happen with StringReader
    }
    // Error detected, return the source
    return css;
}
</code></pre>
<h3 class="subtema" id="yuicompressor">Beware of YUI Compressor</h3>
<p>For further minification, you could choose to apply a specialized minification utility to the output of
<code>toMinifiedString()</code>, and <a href="https://github.com/yui/yuicompressor" target="_blank">YUI
Compressor</a> was a popular choice. But
<a href="https://yahooeng.tumblr.com/post/96098168666/important-announcement-regarding-yui" target="_blank">that
library is not maintained anymore</a> and the latest release was done in 2013: if you decide to apply the
YUI Compressor anyway, beware that it will break <code>calc()</code> expressions and other stuff.</p>
<p>Although there are a few post-2.4.8 updates that were applied to the Compressor's <code>master</code>
branch on its <a href="https://github.com/yui/yuicompressor" target="_blank">Github repository</a>, that
code is completely broken: it does not compile and at least one of the new regular expressions is wrong.</p>
</div>
<div class="tema" id="sheetcomments">
<h2>Accessing style sheet comments</h2>
<p>CSS style sheets often have comments, like:</p>
<pre class="code"><code class="language-css">/* This is a preceding comment */
p {color: blue; } /* This is a trailing comment */
</code></pre>
<p><em>(XML-style comments can also be present in a style sheet, but both NSAC and the CSSOM skip them.)</em></p>
<p>There is no standard CSSOM API for accessing comments in style sheets, but the <a class="codeitem"
href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSRule.html#getPrecedingComments()">CSSRule.getPrecedingComments()</a>
and <a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSRule.html#getTrailingComments()">CSSRule.getTrailingComments()</a>
methods are provided for that:</p>
<pre class="code"><code class="language-java">StringList pcomments = document.getStyleSheets().item(0).getCssRules().item(3).getPrecedingComments();
StringList tcomments = document.getStyleSheets().item(0).getCssRules().item(3).getTrailingComments();
</code></pre>
<p>Other API models were considered for object-model comments, like having a special type of comment rule, but stylesheet-level comments
are often related to a rule and if that rule is moved or deleted, those stand-alone comments would have the potential to create
a lot of confusion.</p>
<p>By default, comments are parsed with the <code><a href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheet.html#COMMENTS_AUTO">COMMENTS_AUTO</a></code>
mode, which should be appropriate for human-readable sheets like the one shown above. But a lot of sheets are serialized
in a way that there are no newline characters (or only a few). For these cases, 
<a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheet.html#COMMENTS_PRECEDING">COMMENTS_PRECEDING</a> could be used in
<a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/AbstractCSSStyleSheet.html#parseStyleSheet(java.io.Reader,short)">parseStyleSheet(Reader,short)</a>,
and all the comments will be considered as belonging to the next rule. With <code><a href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSStyleSheet.html#COMMENTS_IGNORE">COMMENTS_IGNORE</a></code>,
all comments found while parsing the sheet will be ignored.</p>
<p>The comments preceding/trailing any rule will be included in the text returned by the sheet's <code>AbstractCSSStyleSheet.toString()</code> and
<code><a href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/om/AbstractStyleSheet.html#toStyleString()">toStyleString()</a></code> methods,
while other comments (located at places that cannot be easily related to a rule) are lost.</p>
<p>In css4j version 1.0, comments that were intended to apply to the previous rule may be assigned to the next one,
but this is addressed in version 2.0 where NSAC 2.0 allows a more accurate approach.</p>
<p>Comments in the default HTML UA style sheet are not available, as the parser is instructed to ignore them when parsing.</p>
</div>
<div class="tema" id="renderinterfaces">
<h2>Providing device information for style computation</h2>
<p>One of the most important functionalities in the library is the ability to compute styles for a given element.</p>
<p>In practice, to obtain the 'computed' or 'used' values required for actual rendering, a box model implementation
is needed, and also device information. The library provides a simple box model that could be used, but the details
of the rendering device can be more difficult.</p>
<p>Depending on the use case, the target device may not be the same one where the library is running (and some exact
details hence not available). To help in the computation, this library provides a few helper interfaces. The most
important are:</p>
<ul><li><a class="itemtitle codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/agent/DeviceFactory.html"
>DeviceFactory</a>. Delivers the relevant abstractions for a requested medium: <code>StyleDatabase</code> and
<code>CSSCanvas</code> (also provides the objects required by media queries to work).</li></ul>
<ul><li><a class="itemtitle codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/StyleDatabase.html">StyleDatabase</a>.
Provides medium-specific information like available fonts and colors.</li></ul>
<ul><li><a class="itemtitle codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSCanvas.html">CSSCanvas</a>.
Has knowledge of medium-specific information that depends (or may depend) on a specific viewport, like supported media features. It is linked
to a viewport, if there is any. This interface is used to determine the state of active pseudo-classes.</li></ul>
<ul><li><a class="itemtitle codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/Viewport.html">Viewport</a>. It represents a viewport defined
as per the CSS specifications.</li></ul>
<p>The differences between style databases and canvases can be subtle, and for some media features it could be argued that they belong to
one or the other. The basic idea is that style databases should be relatively easy to implement for a given medium, while canvases are
probably only going to exist if there is an actual rendering engine implemented.</p>
<p>For an example implementation of a <code>DeviceFactory</code> and related classes, please check out
<code>MyDeviceFactory</code>, <code>MyStyleDatabase</code> and <code>MyCanvas</code> in EchoSVG's <a class="codeitem" href="https://github.com/css4j/echosvg/blob/master/echosvg-transcoder/src/main/java/io/sf/carte/echosvg/transcoder/util/CSSTranscodingHelper.java">CSSTranscodingHelper</a>,
or <a class="codeitem" href="https://github.com/css4j/css4j-awt/blob/master/src/io/sf/carte/doc/style/css/awt/AWTStyleDatabase.java">AWTStyleDatabase</a> in the <a href="https://github.com/css4j/css4j-awt"><code>css4j-awt</code> project</a>.</p>
</div>
<div class="tema" id="awt">
<h2>Create an AWT font/color from a computed style (css4j-awt module)</h2>
<p>Once you have a computed style, on systems where AWT is available you can create an AWT font or color
with the <code>createFont</code> and <code>getAWTColor</code> static methods found in the <a class="codeitem"
href="api/latest/io.sf.carte.css4j.awt/io/sf/carte/doc/style/css/awt/AWTHelper.html">AWTHelper</a> class:</p>
<pre class="code"><code class="language-java">CSSComputedProperties style = ...
java.awt.Font font = AWTHelper.createFont(style);
CSSTypedValue cssColor = (CSSTypedValue) style.getPropertyCSSValue("color");
java.awt.Color color = AWTHelper.getAWTColor(cssColor);
</code></pre>
<p>Note that <code>AWTHelper.createFont</code> requires a computed style as argument, while the
<code>AWTHelper.getAWTColor</code> method can create colors from any typed value that represents
a color, regardless of it coming from a computed style or a style declaration (the
<code>getPropertyCSSValue</code> shown above does not require the style to be computed).</p>
<p>These classes and methods belong to the <a href="api/latest/io.sf.carte.css4j.awt/module-summary.html"
>css4j-awt module</a> (which is the only css4j module that has a dependency on <a
href="https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/module-summary.html">AWT</a>).</p>
</div>
<div class="tema" id="css3">
<h2>CSS3 support</h2>
<p>CSS3 (defined as "all CSS after CSS2.1") is partially supported by the library; the following table summarizes the
support (supporting generally means that it can decompose shorthands, initial values are known, the rules are in the
Object Model, etc.):</p>
<table id="spectbl">
<tr class="hdrow"><th>CSS3 Spec Name</th><th class="yesno">Support</th><th>Observations</th></tr>
<tr class="evenrow"><td><a href="https://www.w3.org/TR/css-animations-2/">Animations 2</a></td><td class="yesno"
>Yes</td><td class="obsrv">Supports the <code>@keyframes</code> rule and decomposes the the <code>animation</code>
shorthand.</td></tr>
<tr class="oddrow"><td><a href="https://www.w3.org/TR/css-backgrounds-3/">Background / Border 3</a></td><td class="yesno">Yes</td><td class="obsrv"></td></tr>
<tr class="evenrow"><td><a href="https://www.w3.org/TR/css-color-4/">Color 4</a></td><td class="yesno">Yes</td><td class="obsrv"></td></tr>
<tr class="oddrow"><td><a href="https://www.w3.org/TR/css-color-5/">Color 5</a></td><td class="yesno">Partial</td>
<td class="obsrv">Supports full level 4 but only <code>color-mix()</code> from level 5 (this is aligned with web browser
support at the time of writing).</td></tr>
<tr class="evenrow"><td><a href="https://www.w3.org/TR/css-fonts-4/">Fonts 4</a></td><td class="yesno"
>Partial</td><td class="obsrv">Has the <code>@font-face</code> and <code>@font-feature-values</code> rules,
also decomposes the the <code>font</code> shorthand.</td></tr>
<tr class="oddrow"><td><a href="https://www.w3.org/TR/mediaqueries-4/">Media Queries 4</a></td>
<td class="yesno">Partial</td><td class="obsrv">Event handling with addListener/removeListener is not supported.
Relies on <code>CSSCanvas</code> implementations to match/unmatch media features.</td></tr>
<tr class="evenrow"><td><a href="https://www.w3.org/TR/selectors-4/">Selectors 4</a></td><td class="yesno">Yes</td>
<td class="obsrv"></td></tr>
<tr class="oddrow"><td><a href="https://www.w3.org/TR/css-lists-3/">Lists and Counters 3</a></td><td class="yesno">Partial</td><td class="obsrv">Decomposes the <code>list-style</code> shorthand. <em>Limited support by the simple box model.
</em></td></tr>
<tr class="evenrow"><td><a href="https://www.w3.org/TR/css-multicol-1/">Multi-column Layout</a></td><td class="yesno">Partial</td><td class="obsrv">Decomposes the <code>columns</code> shorthand. <em>Not supported by the simple box model.
</em></td></tr>
<tr class="oddrow"><td><a href="https://www.w3.org/TR/css-masking-1/">Masking</a></td><td class="yesno">Partial</td><td class="obsrv">Decomposes the <code>mask</code> shorthand. <em>Not supported by the simple box model.</em></td></tr>
<tr class="evenrow"><td><a href="https://www.w3.org/TR/css-transitions-1/">Transitions</a></td><td class="yesno">Yes</td><td class="obsrv">Decomposes the <code>transition</code> shorthand.</td></tr>
<tr class="oddrow"><td><a href="https://www.w3.org/TR/css-values-4/">Values 4</a></td><td class="yesno">Yes</td><td class="obsrv">Advanced <code>attr()</code> from level 5 also has early support.</td></tr>
<tr class="evenrow"><td><a href="https://www.w3.org/TR/css-variables-1/">Variables</a></td><td class="yesno">Yes</td><td class="obsrv"><code>var()</code> is supported in computed styles.</td></tr>
<tr class="oddrow"><td><a href="https://www.w3.org/TR/css-properties-values-api-1/">CSS Properties and Values API</a></td><td class="yesno">Yes</td><td class="obsrv">Full support (also in computed styles).</td></tr>
<tr class="evenrow"><td><a href="https://www.w3.org/TR/css-grid-1/">Grid / Template / Alignment</a></td>
<td class="yesno">Partial</td><td class="obsrv">Legacy gap properties (<code>grid-row-gap</code>,
<code>grid-column-gap</code>, and <code>grid-gap</code>) are not supported, although the longhands
can be used if declared explicitly). <em>Not supported by the simple box model.</em></td></tr>
</table>
<h3 class="subtema" id="pseudoclasses">Pseudo-classes</h3>
<p>The following pseudo-classes are supported by the library:
<code>first-child</code>, <code>last-child</code>, <code>only-child</code>, <code>nth-child()</code>, <code>nth-last-child()</code>, <code>first-of-type</code>,
<code>last-of-type</code>, <code>only-of-type</code>, <code>nth-of-type()</code>, <code>nth-last-of-type()</code>, <code>dir</code>, <code>lang</code>,
<code>any-link</code>, <code>link</code>, <code>visited</code>, <code>target</code>, <code>root</code>, <code>empty</code>, <code>blank</code>,
<code>disabled</code>, <code>enabled</code>, <code>read-write</code>, <code>read-only</code>, <code>is</code>, <code>where</code>, <code>has</code>,
<code>not</code>, <code>placeholder-shown</code>, <code>default</code>, <code>checked</code> and <code>indeterminate</code>.</p>
<p>State pseudo-classes like <code>hover</code> are supported through the
<a class="codeitem" href="api/latest/io.sf.carte.css4j/io/sf/carte/doc/style/css/CSSCanvas.html#isActivePseudoClass(io.sf.carte.doc.style.css.CSSElement,java.lang.String)">CSSCanvas.isActivePseudoClass(CSSElement, String)</a> method.</p>
</div>
<div class="tema" id="jrereq">
<h2>Java&trade; Runtime Environment requirements</h2>
<p>The classes in the binary packages have been compiled with a Java compiler with 1.8 compiler compliance level,
except for the <code>module-info</code> file which targets Java 11. If you are stuck with Java 7, you may want to use css4j 1.3.1.</p>
</div>
</div>
<div class="footnote"></div>
</div>
</div>
</body>
</html>
